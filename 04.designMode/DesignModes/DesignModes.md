/*
*┌────────────────────────────────────────────────┐
*│　描   述：DesignModes                                                    
*│　作   者：sha                                              
*│　版   本：1.0                                              
*│　创建时间：2020/7/22 9:35:27                        
*└────────────────────────────────────────────────┘
*/
# 设计模式详解 #
## 为什么使用设计模式 ##
> 1:提示自己代码质量

> 2:提高复杂代码的设计和开发能力，设计出扩展性良好，可维护性更强，可复用性更好的代码

> 3:让读源码、学框架事半功倍，学会设计模式，在看框架源码的时候会更好的理解框架中的一些功能设计

> 4:为你的职场发展做铺垫，提升自己 code review 能力，把控团队代码质量

## 设计模式设计原则 ##
设计原则是指导我们代码设计的一些经验总结，对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。
### 单一职责原则 ###
> 对于一个类而言，应该仅有一个引起它变化的原因

> 如果一个类承担的职责过多，就等于把这些职责耦合再一起，一个职责的变化可能会削弱或者抑制这个类完全其他职责的能力。 

> 这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。

### 开放-封闭原则 ###
> 开放-封闭原则是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。

> 对于扩展开放，对于更改封闭

### 依赖倒转原则 ###
> 高层模块不应该依赖低层模式，两个都应该依赖抽象。

> 抽象不应该依赖细节，细节应该依赖于抽象。基于接口编程。

### 里氏代换原则 ###
> 子类型必须能够替换掉它们的父类型

### 接口隔离原则 ###
> 使用多个隔离的接口,比使用单个接口好，建立最小的接口

> 一个接口只负责一个功能

### 迪米特法则 ###
> 如果两个类不必彼此通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。

> 类的结构设计上，每一个类都应当尽量降低成员的访问权限

> 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类别修改，不会对有关系的类造成波及

## 设计模式分类 ##
### 创建型模式（Create） ###
#### 1.简单工厂(SimpleFactory) ####
> 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
简单工厂模式是工厂模式家族中最简单实用的模式，但不属于23种GOF设计模式之一。因为每次要新增类型的时候必须修改工厂内部代码，不符合开闭原则。在实际的业务代码里，简单工厂的应用还是蛮多的。
#### 2.抽象工厂（AbstractFactory） ####
> 1:抽象工厂模式，提供一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

> 2:抽象工厂与工厂模式的区别:

>  1.工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类 

>  2.抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类 

>  3.区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

>  4.再通俗深化理解下：
      1.工厂模式针对的是一个产品等级结构 ，
      2.抽象工厂模式针对的是面向多个产品等级结构的。

>  5.抽象工厂关键在于产品之间的抽象关系，所以一般至少要两个产品；

>  6.工厂方法在于生成产品，不关注产品间的关系，所以可以只生成一个产品。

>  7.抽象工厂更像一个复杂版本的策略模式，策略模式通过更换策略来改变处理方式或者结果；而抽象工厂的客户端，通过更换工厂而改变结果。

>  8.工厂方法目的是生产产品，所以能看到产品，而且还要使用产品。当然，如果产品在创建者内部使用，那么工厂方法就是为了完善创建者，从而可以使用创建者。另外创建者本身是不能更换所生产产品的。

>  9.抽象工厂的工厂是类；工厂方法的工厂是方法。

>  10.抽象工厂的工厂类就做一件事情生产产品。生产的产品给客户端使用，绝不给自己用。

>  11.工厂方法生产产品，可以给系统用，可以给客户端用，也可以自己这个类使用。自己这个类除了这个工厂方法外，还可以有其他功能性的方法。
#### 3.工厂方法（FactoryMethod） ####
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。

> 特点：工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现客户端的操作，也会存在着选择判断的问题，不过和简单工厂相比，简单工厂的选择判断是在工厂内部，而工厂方法则将选择判断转移到了客户端。

#### 4.建造者模式（Builder） ####
> 建造者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。

#### 5.原型模式（Prototype）####
> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

> 原型模式其实就是从一个对象再创建另外一个可定制的对象而且不需要知道任何创建的细节。

#### 6.单列模式（Singleton） ####
> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

> 单例模式主要用来确保某个类型的实例只能有一个。比如手机上的蓝牙之类的只能有一个的实例的场景可以考虑用单例模式。

> 基本实现方式是将构造方法私有化，让实例的过程控制在类的内部去完成并对外部提供一个访问实例的方式。

### 结构型模式（Structure） ###
#### 1.适配器模式（Adapter) ####
> 适配器模式，将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。也被称为 Wrapper 模式。
通常这个类是外部的类，不能直接修改，所以需要做一层包装，以适配现有的接口。
#### 2.桥接模式（Bridge) ####
> 桥接模式，将抽象部分与它的实现部分分离，使得它们都可以独立地变化。

> 这里说到抽象与它的实现分离指的是抽象类和它的派生类用来实现自己的对象
#### 3.组合模式（Composite） ####
> 组合模式，将对象组合成树形结构以表示 “部分-整体” 的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

> 使用场景：当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。

#### 4.装饰者模式（Decorator） ####
> 装饰模式，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活

> 适用场景：装饰模式是为已有功能动态地添加更多功能的一种方式
当系统需要新功能的时候，是向旧的类中添加新的代码，这些新加的代码通常装饰了原有类的核心职责或主要行为，但是往往会在主类中加入新的字段/方法/逻辑，从而增加了主类的复杂度， 而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要
装饰模式提供了一个很好的方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它要装饰的对象， 当需要执行特殊行为时，就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。
装饰模式的优点时把类中的装饰功能从类中搬移去除，这样可以简化原有的类，这样做就有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。
#### 5.外观门面模式（Facade） ####
> 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
#### 6.享元模式（Flyweight) ####
> 享元是指一个可复用的对象，通过复用这个享元来减少应用中的内存分配。
享元模式是为了减少内存占用，尽可能复用已有对象的设计模式，一般来说会把这个可复用的对象放到一个外部的数据结构中，当需要使用到的时候传给享元。

#### 7.代理模式（Proxy） ####
> 代理模式，给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
比如生活中常见的中介，VPN，网络代理等
利用代理模式，我们可以对实际的操作做一些额外的逻辑，比如加一些异常捕捉，缓存，日志记录或者耗时统计等等，基于动态代理的 AOP 模式也是代理模式的实际应用。

### 行为型模式（Behavior） ###

#### 1.观察者模式（Observer) ####
> 观察者模式又叫做 发布订阅（Publish/Subscribe）模式 观察者模式定义了一种一对多的依赖关系，让多个观察者同时监听某一主题对象。 这个主题对象在状态发生变化时，会通知所有观察者对象，使得他们能够自动更新自己。

> 使用场景：观察者模式所做的工作其实就是在解耦，让耦合的双方都依赖于抽象而不是具体，从而使得各自的变化都不会影响另一边的变化。
当一个对象的改变需要改变其他对象的时候，而且它不知道具体有多少对象有待改变的时候，应该考虑使用观察者模式。
一个抽象模型有两方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使得他们各自独立地改变和复用。
#### 2.模版方法（TemplateMethod） ####
> 模板方法模式，定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算的结构即使重定义该算法的某些特定步骤

> 使用场景： 模板方法模式是通过把不变行为搬移到基类中，去除子类中的重复代码来体现它的优势，提供了一个很好的代码复用平台。
当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现，我们通过可以借助模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。
#### 3.命令模式（Command) ####
> 命令模式，将一个请求封装为一个对象，从而使得可以用不同的请求进行参数化，对请求排队或者记录请求日志以及支持可撤销的操作。
命令模式是对命令进行封装，由调用者发起命令请求，接收者执行请求。
当我们调用时，执行的时序首先是调用者类，然后是命令类，最后是接收者类。 也就是说一条命令的执行被分成了三步，它的耦合度要比把所有的操作都封装到一个类中要低的多， 而这也正是命令模式的精髓所在：把命令的调用者与执行者分开，使双方不必关心对方是如何操作的。
#### 4.状态模式（State) ####
> 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

> 使用场景：当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时就可以考虑状态模式。
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。
状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分隔开来。将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个 State 中，所以通过定义新的子类可以很容易地增加新地状态和转换。
状态模式通过把各种状态转义逻辑分布到 State 地子类之间，来减少相互之间地依赖。
#### 5.职责链模式（Chain of Responsibility) ####
> 职责链（责任链）模式，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。 发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。
#### 6.解释器模式（Interpreter） ####
> 解释器模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
这和解释型编程语言的解释器有点类似，要根据一段输入转换成一段输出，将不易读的文本转换为易读的文本，将机器不能识别的输入转成二进制机器可读的输出
当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时，可以使用解释器模式。
#### 7.中介者模式（Mediator） ####
> 1：中介者模式，用一个中介对象来封装一系列的对象交互。 中介者使得各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

> 2：使用场景：中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类种的行为而又不想生成太多子类的场合。

> 3：优缺点：
> 中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了“多对多”交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。

> 优点：中介者（Mediator）的出现减少了各个 Colleague 的耦合，使得可以独立地改变和复用各个 Colleague 类和 Mediator；其次，由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统

> 缺点： 由于 ConcreteMediator 控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个 ConcreteColleague 都复杂
#### 8.访问者模式（Visitor） ####
> 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

> 1.使用场景：访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用域结构上的操作之间的耦合解脱开，使用操作集合可以相对自由地演化。
访问者模式的目的是要把处理从数据结构分离出来，有比较稳定的数据结构，又有易于变化的算法时，使用访问者模式就是比较适合的， 因为访问者模式使得算法操作的增加变得容易。反之，如果数据结构对象易于变化，经常有新的数据对象增加进来，就不适合使用访问者模式。

> 2.优缺点：

> 优点：增加新的操作很容易，增加新的操作就意味着增加一个新的访问者，访问者模式将有关的行为集中到一个访问者对象中。

> 缺点：增加新的数据结构困难，破坏 开放封闭 原则
#### 9.备忘录模式（Memento） ####
> 备忘录模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

> 使用场景： 备忘录（Memento）模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，
Originator 可以根据保存的 Memento 信息还原到前一状态。
可以用来做数据(状态)备份和恢复。
#### 10.迭代器模式（Iterator） ####
> 迭代器模式，提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
迭代器模式是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据。

> 使用场景：当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式。
当你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。
#### 11.策略模式（Strategy) ####
>  它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的 Context。
策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完全的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用类之间的耦合。

> 使用场景：策略模式就是用来封装算法的，但在实践中也可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。

> 优点：
减少了具体的算法和使用算法类之间的耦合
策略模式的 Strategy 类层为 Context 定义了一系列的可供重用的算法或行为，继承有助于析取这些算法中的公共功能
简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试


# 修饰符隔离级别 #
> 程序的级别：项目、解决方案、程序集、命名空间四个容易混淆的概念。

> ①项目：就是我们开发的一个软件。.NET下，项目有多种类型，如控制台、Windows应用程序、类库、Web应用程序等等。经过编译后，会生成.exe文件和.dll文件。
.exe文件有统一的主程序入口， 可以被执行，而类库只是提供一些功能给其他项目调用。

> ②解决方案：当我们在VS中新建任何一种类型项目时，这个项目还属于一个解决方案。当我们的业务相对简单时，解决方案所发挥的作用并不是很大。但当我们开发复杂的软件时，需要多个模块组成。 比如说开发中常用的三层架构，U层是一个简单的windows应用程序（项目的一种类型）、B、D层由多个类库(项目的另一种类型)组成。通过一个解决方案，我们就可以将其(多个项目)组合起来，完成我们的开发。 形象地说，解决方案就是一个容器，在这个容器里，分成好多层，好多格，用来存放不同的项目。换句话来说：就是《程序集就是一个项目，多个项目构成一个解决方案》

> ③程序集：一个项目就是一个程序集。一个程序集可以体现为一个dll文件，或者exe文件。

> ④命名空间：主要是为了避免一个项目中，可能会存在的相同对象名的冲突。
对于编辑来说,命名空间仅仅是在类型名称前加了一些由点号隔开的符号而已.这使得一个类型的名称更长,从而也更具惟一性.如果两个相同的类在同一个命名空间则会冲突,如果不同的命名空间有相同的类型,也会产生二义性。 注意,C#的using指示符会指示编译器试着在类型名上添加不同的前缀,直到找到一个匹配为止,命名空间只是逻辑上,真正的类型在程序集里,当查找一个类型的定义时,编
译器必须被告知到哪些程序集中进行查找,编译器将扫描它知道的所有程序集来查找类型的定义.一旦编译器找到了正确的程序,程序集信息和类型信息会被添加到生成托管
模块的元数据中。重要提示：CLR不知道命名空间的任何事情。访问一个类型时，CLR需要知道类型的完整名称（这可能是一个相当长、包含句点符号的名称）以及该类型的定义具体在哪一个程序集中.
这样一样，“运行时”才能加载正确的程序集，找到目标类型，并对其进行操作。

##  联系与区别 ##
> 1、命名空间是类库的逻辑组织形式，程序集就是类库的物理组织形式。

> 2、一个程序集内可能有多个命名空间，一个命名空间可能存在于不同的程序集中 

> 3、程序集是实现类型的文件，编译之后生成的。命名空间是对类型的逻辑分组。 

> 4、c#编译器可能比较关心命名空间，应为它需要确定类的完整名称，然后交给CLR。 
CLR只关心程序集，会通过类的完整名称加载对应的程序集

## 总结 ## 
> 通过在项目中使用分部类，发现可以通过分部类实现对这个类的扩充和完善。而使用分部类时我们会对命名空间进行修改，近而将类进行扩展；这就是我们说的一个命名空间可以存在于不同的程序集。

## 修饰词范围 ##
> public  ：公有访问。不受任何限制。

> private  ： 私有访问。只限于本类成员访问，子类，实例都不能访问。

> protected  ：保护访问。只限于本类和子类访问，实例不能访问。

> internal  ：内部访问。只限于本项目内访问，其他不能访问。

> protected internal ： 内部保护访问。只限于本项目或是子类访问，其他不能访问

### internal 和 protected 、 proteccted internal 的三个区别 ###
> 1.internal（内部）：限定的是只有在同一程序集中可访问，可以跨类    

> 2.protected（受保护）：限定的是只有在继承的子类中可访问，可以跨程序集     

> 3.protected internal：受保护“或”内部修饰符修饰成员,当父类与子类在同一个程序集中，internal成员可见。当父类与子类不在同一个程序集中，子类不能访问父类internal成员，
而子类可以访问父类的ptotected internal成员，
即从当前程序集或从包含类派生的类型，可以访问具有访问修饰符 protected internal 的类型或成员。 

> 4.internal 关键字是类型和类型的成员 访问修饰符。只有在同一程序集的文件中，内部类型或成员才是可访问的内部访问通常用于基于组件的开发，因为它使一组组件能够以私有方式进行合作，而不必向应用程序代码的其余部分公开。
例如，用于生成图形用户界面的框架可以提供 Control 和 Form 类，这两个类通过使用具有内部访问权限的成员进行合作。由于这些成员是内部的，它们不向正在使用框架的代码公开。

> 5.从定义具有内部访问能力的类型或成员的程序集外部引用该类型或成员是错误的。